<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>

<head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">

    <title>RTRoute v0.18</title>
<!--
RELEASE INFO:
    2017-12-01 imported stops, journeys and trip data, draw_stops and draw_route code
    2017-11-30 Moved code into rtroute.html to experiment with route calculations
    ----
    2017-11-26 generalized from buses, latest full data in popup, icon resize on old data,
               map can go fullscreen
    2017-11-25 supports connect, close, subscribe, request with filters '=' and 'inside'
                console log using divs, draw polygon, clear icons
    2017-11-14 page working for connect, subscribe, close
    2017-11-11 initial version to connect websocket to vertx rtmonitor
-->	
<style type="text/css">
html {
    height: 100%;
}

body {
    font-family: sans-serif;
    height: 100%;
}

#rt_scratchpad {
    font-size: x-small;
    width: 95%;
    height: 40%;
}

#map {
	display: inline-block;
	width: 68%;
    height: 80%;
} 

#console_div {
    margin-top: 10px;
}

.top-aligned {
    vertical-align: top;
}

.control_box {
    padding: 6px;
}

.scratchpad_box {
    width: 100%;
    height: 90%;
}

.control_div {
    display: inline-block;
    width: 30%;
    height: 80%;
}

.sensor-popup {
    font-size: small;
}

.marker_sensor_M {
    background-image: url("/static/images/bus_logo_M.png");
    /* background-color: green; */
}

.marker_sensor_L {
    background-image: url("/static/images/bus_logo_L.png");
    /* background-color: green; */
}

.marker_label_M {
    /* background-color: white; */
    /* margin-left: 8px; */
    margin-top: 7px;
    font-size: 7px;
    text-align: center;
}

.marker_label_L {
    /* background-color: white; */
    /* margin-left: 8px; */
    margin-top: 8px;
    font-size: 11px;
    text-align: center;
}

.log_record {
}

.log_msg {
    display: inline-block;
    margin-left: 1em;
}

.log_ts {
    display: inline-block;
}

.log_record_odd {
    background-color: lightblue;
}

.log_record_even {
    background-color: lightgray;
}

.log_error {
    color: red;
}

</style>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />

<script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>

<link rel="stylesheet" href="/static_web/map.css" />

<script type="text/javascript" src="/static_web/js/MovingMarker.js"></script>

<!-- ********************************************************************************* -->
<!-- load stops and journey data for OriginRef 0500CCAMB011 (De La Warr Way Cambourne) -->

<!-- create js object rtroute_journeys (every timetable journey from Cambourne) -->
<script type="text/javascript" src="rtroute_journeys.js"></script>

<!-- create js object rtroute_stops (all stops used in above journeys) -->
<script type="text/javascript" src="rtroute_stops.js"></script>

<!-- create array of sirivm js objects rtroute_trip (one sample journey) -->
<script type="text/javascript" src="rtroute_trip.js"></script>

<!-- WebSockets library to connect to RTMonitor -->
<script src="sockjs.min.js"></script>

<script>

// ***************************************************************************
// *******************  Page and map code ************************************
// ***************************************************************************
// Constants

var RTMONITOR_URI = 'http://tfc-app2.cl.cam.ac.uk/rtmonitor/sirivm';

var MAP_CENTER = [52.218, -0.0666];//[52.205, 0.119];
var MAP_SCALE = 15;//13;

var OLD_TIMER_INTERVAL = 30; // watchdog timer interval (s) checking for old data records
var OLD_DATA_RECORD = 60; // time (s) threshold where a data record is considered 'old'

// Globals

var map;       // Leaflet map
var map_tiles; // map tiles layer

var DEBUG_VEHICLE_JOURNEY_ID = "20-4-_-y08-1-51-T0";

var urlparams = new URLSearchParams(window.location.search);
var debug = urlparams.has('debug');
var mapbounds;

var clock_time; // the 'current time', either now() or replay_time

var console_div;

// *********************************************************
// RTRoutes globals

// Local dictionary of STOPS keyed on stop_id
// Sample stop record in rtroute_stops:
// { stop_id:'0500CCITY055', lat:52.2114061236, lng:0.10481260687, common_name:'Storey\'s Way'},
// becomes
// stops['0500CCITY055'] = {this stop record}
var stops = {};

// Local dictionary of JOURNEYS keyed on vehicle_journey_id
// Sample journey data record in rtroutes_journeys:
// {vehicle_journey_id:'20-4-_-y08-1-98-T2',order:1,time:'11:22:00',stop_id:'0500SCAMB011'},
// becomes:
// journeys['20-4-_-y08-1-98-T2'] = { route: [ ... {above record} ] }
var journeys = {};
var journeys_count = 0;

// Trip data (from rtroutes_trip.js)
//  { "Delay": "PT0S", 
//    "acp_id": "SCCM-19611", 
//    "acp_ts": 1511156152, 
//    "Bearing": "0",
//    "InPanic": "0", 
//    "LineRef": "4", 
//    "acp_lat": 52.230381,
//    "acp_lng": 0.159207,
//    "Latitude": "52.2303810",
//    "Longitude": "0.1592070",
//    "Monitored": "true",
//    "OriginRef": "0500SCAMB011", 
//    "OriginName": "De La Warr Way", 
//    "VehicleRef": "SCCM-19611", 
//    "OperatorRef": "SCCM", 
//    "DataFrameRef": "1", 
//    "DirectionRef": "INBOUND", 
//    "DestinationRef": "0500CCITY484", 
//    "RecordedAtTime": "2017-11-20T05:35:52+00:00", 
//    "ValidUntilTime": "2017-11-20T05:35:52+00:00", 
//    "DestinationName": "Drummer Str Stop D3", 
//    "PublishedLineName": "4", 
//    "VehicleMonitoringRef": "SCCM-19611", 
//    "DatedVehicleJourneyRef": "2", 
//    "OriginAimedDepartureTime": "2017-11-20T06:02:00+00:00"
//    },

// Data recording
var recorded_records = [];
var recording_on = false;

// Replay
var replay_time; // holds unix timestamp (secs since 1970), current time of replay
var replay_timer; // the JS interval timer for the replay function
var replay_on = false; // Replay mode on|off
var replay_interval = 1; // Replay step interval (seconds)
var replay_speedup = 10; // relative speed of replay time to real time
var replay_index = 0; // current index into replay data

// *********************************************************
// Display options

var breadcrumbs = false; // location 'breadcrumbs' will be dropped as things move

var map_only = false; // page is in "only display map" mode

// *****************
var sensors = {};

// Here we define the 'data record format' of the incoming websocket feed
var RECORD_INDEX = 'VehicleRef';  // data record property that is primary key
var RECORDS_ARRAY = 'request_data'; // incoming socket data property containing data records
var RECORD_TS = 'RecordedAtTime'; // data record property containing timestamp
var RECORD_TS_FORMAT = 'ISO8601'; // data record timestamp format
                                  // 'ISO8601' = iso-format string
var RECORD_LAT = 'Latitude';      // name of property containing latitude
var RECORD_LNG = 'Longitude';     // name of property containing longitude

// *****************
// Map globals
var ICON_URL = '/static/images/bus-logo.png';

var crumbs = []; // array to hold breadcrumbs as they are drawn

var icon_size = 'L';

var oldsensorIcon = L.icon({
    iconUrl: ICON_URL,
    iconSize: [20, 20]
});

// *************************
// **** Routes stuff

var bus_stop_icon = L.icon({
    iconUrl: '/static/images/bus_stop.png',
    iconSize: [15,40],
    iconAnchor: [3,40]
});

// ************************
// User 'draw polygon' global vars
var poly_draw = false; // true when user is drawing polygon
var poly_markers = [];
var poly_line; // open line around polygon
var poly_close; // line between poly last point and start, closing polygon

// *********************************************************************************
// *********************************************************************************
// ********************  INIT RUN ON PAGE LOAD  ************************************
// *********************************************************************************
// *********************************************************************************
function init()
{
    // initialize log 'console'
    console_div = document.getElementById('console_div');

    // initialize map

    var map_options = { preferCanvas: true };

    map = L.map('map', map_options)
            .setView(MAP_CENTER, MAP_SCALE);

    map.on('click',click_map);

    map_tiles = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

    mapbounds = map.getBounds();

    // initialize clock

    update_clock();
    setInterval(update_clock, 1000);

    // initialize UI checkboxes

    document.getElementById('log_append').checked = false;
    document.getElementById('breadcrumbs').checked = false;

    // watchdog timer checking for 'old' data records

    setInterval(check_old_records, OLD_TIMER_INTERVAL*1000);

    // listener to detect 'keydown' while in map_only mode
    document.onkeydown = function(evt) {
            evt = evt || window.event;
            if (map_only)
            {
                page_normal();
            }
    };

    // RTROUTE STUFF

    // build stops dictionary keyed on stop_id
    load_stops();

    // build journeys dictionary keyed on vehicle_journey_id
    load_journeys();

    draw_stops();

} // end init()            

// *********************************************************************************
// ************* RTRoute code      ***************************************************
// *********************************************************************************

// Load the rtroute_stops array (from rtroute_stops.js) into stops dictionary
function load_stops()
{
    for (var i=0; i<rtroute_stops.length; i++)
    {
        stops[rtroute_stops[i].stop_id] = rtroute_stops[i];
    }
}

// Load the rtroute_journeys array (from rtroute_journeys.js) into journeys dictionary
function load_journeys()
{
    // Iterate through all the vehicle_journey_id/stop_id/time/order... records
    for (var i=0; i<rtroute_journeys.length; i++)
    {
        var journey_stop = rtroute_journeys[i];
        var stop_index = journey_stop.order - 1; // order goes 1..n, stop_index starts at 0
        var vehicle_journey_id = journey_stop.vehicle_journey_id;
        var stop = stops[journey_stop.stop_id];

        // For a given row of that data, either create a new journey or add to existing
        if (journeys.hasOwnProperty(vehicle_journey_id))
        {
            var journey = journeys[vehicle_journey_id];

            // Add an arrow from previous stop to this stop
            if (stop_index > 0)
            {
                var prev_stop = stops[journey.route[stop_index - 1].stop_id];
                var diffLat = stop.lat - prev_stop.lat;
                var diffLng = stop.lng - prev_stop.lng;
                var center = [prev_stop.lat + diffLat/2, prev_stop.lng + diffLng/2];
                var angle = (bearing(prev_stop, stop)- 90 + 360) % 360;
                journey.route[stop_index - 1].arrow = new L.marker(
                    center,
                    { icon: new L.divIcon({ 
                                  className : 'arrow_icon',
                                  iconSize: new L.Point(30,30), 
                                  iconAnchor: new L.Point(15,15), 
                                  html : '<div style = "font-size: 20px;'+
                                      '-webkit-transform: rotate('+ angle +'deg)">&#10152;</div>'
                                  })
                    }
                );
            }
            // Add this journey row to an existing journey in dictionary
            journey.route[stop_index] = journey_stop;
        }
        else
        {
            // Create a new journey entry with this vehicle_journey_id
            // Start with route of just this current stop
            var new_route = [];
            new_route[stop_index] = journey_stop;

            // Add this route to a new journeys entry
            journeys[journey_stop.vehicle_journey_id] = {route: new_route};

            journeys_count++; // keep track of total number of journeys
        }
    }
    log(journeys_count + ' journeys created');

}

//debug Given a sirivm msg, return the vehicle journey_id
function sirivm_to_vehicle_journey_id(msg)
{
    return DEBUG_VEHICLE_JOURNEY_ID;
}

function vehicle_journey_id_to_route(vehicle_journey_id)
{
    if (!journeys.hasOwnProperty(vehicle_journey_id))
    {
        return null;
    }
    return journeys[vehicle_journey_id].route;
}

// *********************************************************************************
// ************* Geometric Functions ***********************************************
// *********************************************************************************

// Return distance in m between positions p1 and p2.
// lat/longs in e.g. p1.lat etc
function distance(p1, p2) 
{
    var R = 6371000; // Earth's mean radius in meter
    var dLat = rad(p2.lat - p1.lat);
    var dLong = rad(p2.lng - p1.lng);
    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(rad(p1.lat)) * Math.cos(rad(p2.lat)) *
                        Math.sin(dLong / 2) * Math.sin(dLong / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c;
    return d; // returns the distance in meter
};

// Return true is position is inside bounding polygon
// http://stackoverflow.com/questions/13950062/checking-if-a-longitude-latitude-coordinate-resides-inside-a-complex-polygon-in
function inside(position, bounds_path, box)
{
    // easy optimization - return false if position is outside bounding rectangle (box)
    if ( position.lat > box.north ||
         position.lat < box.south || 
         position.lng < box.west || 
         position.lng > box.east)
        return false;

    var lastPoint = bounds_path[bounds_path.length - 1];
    var isInside = false;
    var x = position.lng;
    for (var i=0; i<bounds_path.length; i++)
    {
        var point = bounds_path[i];
        var x1 = lastPoint.lng;
        var x2 = point.lng;
        var dx = x2 - x1;

        if (Math.abs(dx) > 180.0)
        {
            // we have, most likely, just jumped the dateline 
            // (could do further validation to this effect if needed).  normalise the
            // numbers.
            if (x > 0)
            {
                while (x1 < 0)
                    x1 += 360;
                while (x2 < 0)
                    x2 += 360;
            }
            else
            {
                while (x1 > 0)
                    x1 -= 360;
                while (x2 > 0)
                    x2 -= 360;
            }
            dx = x2 - x1;
        }

        if ((x1 <= x && x2 > x) || (x1 >= x && x2 < x))
        {
            var grad = (point.lat - lastPoint.lat) / dx;
            var intersectAtLat = lastPoint.lat + ((x - x1) * grad);

            if (intersectAtLat > position.lat)
                isInside = !isInside;
        }
        lastPoint = point;
    }

    return isInside;
}


// Bearing in degrees from pos1 -> pos2 as {lat: , lng: }
function bearing(pos1, pos2)
{
    var a = { lat: rad(pos1.lat), lng: rad(pos1.lng) };
    var b = { lat: rad(pos2.lat), lng: rad(pos2.lng) };

    var y = Math.sin(b.lng-a.lng) * Math.cos(b.lat);
    var x = Math.cos(a.lat)*Math.sin(b.lat) - 
                Math.sin(a.lat)*Math.cos(b.lat)*Math.cos(b.lng-a.lng);
    return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
}

// http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
// Detect whether lines A->B and C->D intersect
// return { intersect: true/false, position: LatLng (if lines do intersect), progress: 0..1 }
// where 'progress' is how far the intersection is along the A->B path
function intersect(line1, line2)
{
    var A = line1[0], B = line1[1], C = line2[0], D = line2[1];

    var s1 = { lat: B.lat - A.lat, lng: B.lng - A.lng };
    var s2 = { lat: D.lat - C.lat, lng: D.lng - C.lng };

    var s = (-s1.lat * (A.lng - C.lng) + s1.lng * (A.lat - C.lat)) / 
                (-s2.lng * s1.lat + s1.lng * s2.lat);
    var t = ( s2.lng * (A.lat - C.lat) - s2.lat * (A.lng - C.lng)) / 
                (-s2.lng * s1.lat + s1.lng * s2.lat);

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1)
    {
        // lines A->B and C->D intersect
        return { success: true, 
                 position: { lat: A.lat + (t * s1.lat), 
                             lng: A.lng + (t * s1.lng) }, 
                 progress: t };
    }

    return { success: false }; // lines don't intersect
}

// Perpendicular distance of point P {lat:, lng:} from a line [A,B]
// where A,B are points
function distance_from_line(P, line)
{

    // Prepare some values for the calculation
    var R = 6371000; // Earth's mean radius in meter

    var A = line[0];

    var B = line[1];

    var bearing_AP = bearing(A, P);

    var bearing_AB = bearing(A, B);

    var bearing_BP = bearing(B, P);

    // if point P is 'behind' A wrt to B, then return distance from A
    var angle_BAP = (bearing_AP - bearing_AB + 360) % 360;

    console.log('angle_BAP',angle_BAP);

    if (angle_BAP > 90 && angle_BAP < 270)
    {
        return distance(A,P);
    }

    // if point P is 'behind' B wrt to A, then return distance from B
    var angle_ABP = (180 - bearing_BP + bearing_AB + 360) % 360;

    console.log('angle_ABP',angle_ABP);

    if (angle_ABP > 90 && angle_ABP < 270)
    {
        return distance(B,P);
    }

    // ok, so the point P is somewhere between A and B, so return perpendicular distance

    var distance_AB = distance(A, P);

    var d = Math.asin(Math.sin(distance_AB/R)*Math.sin(rad(bearing_AP - bearing_AB))) * R;
    
    return Math.abs(d);
}

//*********************************************************************************************
//*********************************************************************************************
//*************** CONVERSION FUNCTIONS, E.G. meters to nautical miles *************************
//*********************************************************************************************
//*********************************************************************************************

// degrees to radians
var rad = function(x) {
      return x * Math.PI / 180;
};

// meters to nautical miles
function nm(x)
{
        return x * 0.000539956803;
}

// meters to statute miles
function miles(x)
{
        return x * 0.000621371;
}

// *********************************************************************************
// ************* Sensor update code ***************************************************
// *********************************************************************************

function update_sensor(msg)
{
		// existing sensor data record has arrived

        var sensor_id = msg[RECORD_INDEX];

		if (msg[RECORD_TS] !== sensors[sensor_id].msg[RECORD_TS])
        {
            // move marker
            var position = [msg[RECORD_LAT], msg[RECORD_LNG]];
            var marker = sensors[sensor_id].marker;
		    marker.moveTo(position, [1000] ); 
		    marker.resume();

            // update tooltip and popup
		    marker.setTooltipContent(tooltip_content(msg));
		    marker.setPopupContent(popup_content(msg));

            // store as latest msg
		    sensors[sensor_id].msg = msg; // update entry for this msg
            add_breadcrumb(position);

            var sensor = sensors[sensor_id];

            update_state(sensor);
		}
}

function create_sensor(msg)
{
    // new sensor, create marker
    log(' ** New '+msg[RECORD_INDEX]);

    var sensor_id = msg[RECORD_INDEX];

    var sensor = { sensor_id: sensor_id,
                   msg: msg
                 };

    var marker_icon = create_sensor_icon(msg);

    sensor['marker'] = L.Marker.movingMarker([[msg[RECORD_LAT], msg[RECORD_LNG]], 
                                                   [msg[RECORD_LAT], msg[RECORD_LNG]]],
                                                  [1000],
                                                  {icon: marker_icon});
    sensor['marker']
        .addTo(map)
        .bindPopup(popup_content(msg), { className: "sensor-popup"})
        .bindTooltip(tooltip_content(msg), {
                            // permanent: true,
                            className: "sensor-tooltip",
                            interactive: true
                          })
        .on('click', function()
                {
                  //console.log("marker click handler");
                })
        .start();

    sensors[sensor_id] = sensor;

    init_state(sensor);
}

// Initialize sensor state (e.g. for bus, vehicle_journey_id, route_index)
function init_state(sensor)
{
    //log('Initializing '+sensor.sensor_id);

    sensor.state = {};

    if (!sensor.msg['OriginRef'])
    {
        return;
    }

    sensor.state.vehicle_journey_id = sirivm_to_vehicle_journey_id(sensor.msg);

    // flag if this record is OLD or NEW
    update_old_status(sensor);

    update_route_index(sensor);
}

// Update sensor state
function update_state(sensor)
{
    //log('Updating '+sensor.sensor_id);

    // flag if this record is OLD or NEW
    update_old_status(sensor);

    update_route_index(sensor);

}

// Given a data record, update '.old' property t|f and reset marker icon
// Note that 'current time' is the JS date value in global 'clock_time'
// so that this function works equally well during replay of old data.
function update_old_status(sensor)
{
    var data_timestamp; // will hold Date from sensor

    switch (RECORD_TS_FORMAT)
    {
        case 'ISO8601':
            data_timestamp = new Date(sensor.msg[RECORD_TS]);
            break;

        default:
            return;
    }

    // get current value of sensor.state.old flag (default false)
    var current_old_flag = !(sensor.state.old == null) || sensor.state.old;

    // calculate age of sensor (in seconds) 
    var age = (clock_time - data_timestamp) / 1000;

    if (age > OLD_DATA_RECORD)
    {
        // data record is OLD
        // skip if this data record is already flagged as old
        if (sensor.state.old != null && sensor.state.old)
        {
            return;
        }
        // set the 'old' flag on this record and update icon
        sensor.state.old = true;
        sensor.marker.setIcon(oldsensorIcon);
    }
    else
    {
        // data record is NOT OLD
        // skip if this data record is already NOT OLD
        if (sensor.state.old != null && !sensor.state.old)
        {
            return;
        }
        // reset the 'old' flag on this data record and update icon
        sensor.state.old = false;
        sensor.marker.setIcon(create_sensor_icon(sensor.msg));
    }
}

function update_route_index(sensor)
{
    // If sensor doesn't have a vehicle_journey_id then
    // there's nothing we can do, so return
    if (!sensor.state.vehicle_journey_id)
    {
        return;
    }

    var route = vehicle_journey_id_to_route(sensor.state.vehicle_journey_id);

    //debug here we're hardcoding the start of the journey
    // for testing purposes
    sensor.state.route_index = nearest_route_segment(sensor, route);

    // highlight line on map of next route segment
    var route_index = sensor.state.route_index > 0 ? sensor.state.route_index : 1;
    
    var prev_stop_id = sensor.state.prev_stop_id;

    var next_stop_id = sensor.state.next_stop_id;

    sensor.state.prev_stop_id = route[route_index - 1].stop_id;

    sensor.state.next_stop_id = route[route_index].stop_id;

    if (prev_stop_id != sensor.state.prev_stop_id || next_stop_id != sensor.state.next_stop_id) 
    {
        if (sensor.state.route_segment_line)
        {
            map.removeLayer(sensor.state.route_segment_line);
        }
        sensor.state.route_segment_line = draw_line(stops[sensor.state.prev_stop_id],
                                                stops[sensor.state.next_stop_id],
                                                'green');
        log('Next stop for '+sensor.sensor_id+' is '+sensor.state.next_stop_id);
    }
}

// Given a sensor location, return route_index of nearest route segment
// where the segment is route[route_index-1]..route[route_index]
function nearest_route_segment(sensor, route)
{
    var P = get_point(sensor.msg);

    var min_distance = 999999999;
    var route_index = 0;

    for (var i=1; i<route.length; i++)
    {
        var prev_stop_id = route[i-1].stop_id;
        var next_stop_id = route[i].stop_id;

        var line_distance = distance_from_line(P, [stops[prev_stop_id],stops[next_stop_id]]);
        if (line_distance < min_distance)
        {
            route_index = i;
            min_distance = line_distance;
        }
    }
    return route_index;
}

// return {lat:, lng:} from sensor message
function get_point(msg)
{
    return { lat: msg[RECORD_LAT], lng: msg[RECORD_LNG] };
}

function create_sensor_icon(msg)
{
    var line = '';

    if (msg.LineRef != null)
    {
        line = msg.LineRef;
    }

    var marker_html =  '<div class="marker_label_'+icon_size+'">'+line+'</div>';

    var marker_size = new L.Point(30,30);

    switch (icon_size)
    {
        case 'L':
            marker_size = new L.Point(45,45);
            break;

        default:
            break;
    }

    return L.divIcon({ 
        className: 'marker_sensor_'+icon_size,
        iconSize: marker_size,
        html: marker_html
    });
}

function add_breadcrumb(pos)
{
    if (breadcrumbs)
    {
        var crumb = L.circleMarker(pos, { color: 'blue', radius: 1 }).addTo(map);
        crumbs.push(crumb);
    }
}

function tooltip_content(msg)
{
    var time = new Date();
    var time_str = ("0" + time.getHours()).slice(-2)   + ":" + 
                   ("0" + time.getMinutes()).slice(-2) + ":" + 
                   ("0" + time.getSeconds()).slice(-2);
    return time_str +
                        '<br/>' + msg[RECORD_INDEX] + 
			'<br/>Line "' + msg['PublishedLineName'] +'"'+
                        '<br/>Delay: ' + msg['Delay'];
}

function popup_content(msg)
{
    var time = new Date();
    var time_str = ("0" + time.getHours()).slice(-2)   + ":" + 
                   ("0" + time.getMinutes()).slice(-2) + ":" + 
                   ("0" + time.getSeconds()).slice(-2);
    var sensor_id = msg[RECORD_INDEX];
    return time_str +
        '<br/>' + sensor_id + 
		'<br/>Line "' + msg['PublishedLineName'] +'"'+
        '<br/>Delay: ' + msg['Delay']+
        '<br/><a href="#" onclick="click_journey('+"'"+sensor_id+"'"+')">journey</a>'+
        '<br/><a href="#" onclick="click_more('+"'"+sensor_id+"'"+')">more</a>';
}

// user has clicked on 'more' in the sensor popup
function more_content(sensor_id)
{
    var sensor = sensors[sensor_id];
    var content = JSON.stringify(sensor.msg).replace(/,/g,', ');
    content +=
        '<br/><a href="#" onclick="click_less('+"'"+sensor_id+"'"+')">less</a>';
    return content;
}

// ********************************************************************************
// ********************************************************************************
// ***********  Process the data records arrived from WebSocket or Replay *********
// ********************************************************************************
// ********************************************************************************

// Process websocket data
function handle_records(websock_data)
{
    var incoming_data = JSON.parse(websock_data);
    //console.log('handle_records'+json['request_data'].length);
    for (var i = 0; i < incoming_data[RECORDS_ARRAY].length; i++) 
    {
	    handle_msg(incoming_data[RECORDS_ARRAY][i]);
    }
} // end function handle_records

// Process replay data
function replay_step()
{
    replay_time = replay_time + (replay_interval*replay_speedup);

    var current_index = replay_index;

    // skip earlier records

    while ( replay_index < rtroute_trip.length && 
            rtroute_trip[replay_index]['acp_ts'] < replay_time)
    {
        replay_index++;
    }

    if ( replay_index < rtroute_trip.length 
         && replay_index > current_index)
    {
        var msg = rtroute_trip[replay_index-1];

        var time_str = hh_mm_ss(new Date(msg['acp_ts']*1000));
        var next_time_str = (replay_index < rtroute_trip.length - 1)
                            ? hh_mm_ss(new Date(rtroute_trip[replay_index]['acp_ts']*1000))
                            : '--end of records--';
        log('replay record '+(replay_index-1)+' '+time_str+' next: '+next_time_str);

        handle_msg(msg);
    }

    if ( replay_index == rtroute_trip.length )
    {
        replay_stop();
    }
}

// process a single data record
function handle_msg(msg)
{
    // add to recorded_data if recording is on

    if (recording_on)
    {
        recorded_records.push(JSON.stringify(msg));
    }

    var sensor_id = msg[RECORD_INDEX];

    // If an existing entry in 'sensors' has this key, then update
    // otherwise create new entry.
    if (sensors.hasOwnProperty(sensor_id)) 
    {
        update_sensor(msg);
    }
    else 
    {
        create_sensor(msg);
    }
}

// update realtime clock on page
// called via intervalTimer in init()
function update_clock()
{
    if (replay_on)
    {
        clock_time = new Date(replay_time*1000);
    }
    else
    {
        clock_time = new Date();
    }
    document.getElementById('clock').innerHTML = hh_mm_ss(clock_time);
}

// watchdog function to flag 'old' data records
// records are stored in 'sensors' object
function check_old_records()
{
    //console.log('checking for old data records..,');

    // do nothing if timestamp format not recognised
    switch (RECORD_TS_FORMAT)
    {
        case 'ISO8601':
            break;

        default:
            return;
    }

    for (sensor_id in sensors)
    {
        update_old_status(sensors[sensor_id]);
    }
}

// return provided JS Date() as HH:MM:SS
function hh_mm_ss(datetime)
{
    var hh = ('0'+datetime.getHours()).slice(-2);
    var mm = ('0'+datetime.getMinutes()).slice(-2);
    var ss = ('0'+datetime.getSeconds()).slice(-2);
    return hh+':'+mm+':'+ss;
}

// ***************************************************************************
// *******************  Logging code      ************************************
// ***************************************************************************

var LOG_TRUNCATE = 10; // we'll limit the log to this many messages

var log_record_odd = true; // binary toggle for alternate log background colors

var log_append = false;

function log(msg)
{
    // create HH:MM:SS timestamp for this log record
    var ts = hh_mm_ss(new Date());

    // create outermost log record element
    var new_log_record = document.createElement('div');

    // create timestamp element
    var ts_element = document.createElement('div');
    ts_element.classList.add('log_ts');
    ts_element.innerHTML = ts;
    new_log_record.appendChild(ts_element);

    // create msg element
    var msg_element = document.createElement('div');
    msg_element.classList.add('log_msg');
    msg_element.innerHTML = msg;
    new_log_record.appendChild(msg_element);

    new_log_record.classList.add('log_record');
    // set the log background color and toggle odd/even flag
    new_log_record.classList.add(log_record_odd ? 'log_record_odd' : 'log_record_even');
    log_record_odd = !log_record_odd;

    // if log is full then drop the oldest msg
    if (console_div.childElementCount == LOG_TRUNCATE)
    {
        //console.log('log hit limit '+LOG_TRUNCATE);
        if (log_append)
        {
            //console.log('log removing firstChild');
            console_div.removeChild(console_div.firstChild);
        }
        else
        {
            //console.log('log removing lastChild '+console_div.lastChild.tagName);
            console_div.removeChild(console_div.lastChild);
        }
        //console.log('log record count after removeChild: '+console_div.childElementCount)
    }
    if (log_append)
    {
        console_div.appendChild(new_log_record);
    }
    else
    {
        console_div.insertBefore(new_log_record, console_div.firstChild);
    }
    //console.log('log record count: '+console_div.childElementCount)
}

// reverse the order of the messages in the log
function log_reverse()
{
    for (var i=0;i<console_div.childNodes.length;i++) 
      console_div.insertBefore(console_div.childNodes[i], console_div.firstChild);
}

// ***************************************************************************
// *******************  WebSocket code    ************************************
// ***************************************************************************

var sock; // the page's WebSocket

function sock_connect(method)
{
    // for testing (e.g. on laptop) we can us local port directly
    if (method=="port")
    {
        sock = new SockJS('http://localhost:8099/test/rtmonitor/sirivm');
    }
    else
    {
        sock = new SockJS(RTMONITOR_URI);
    }

    sock.onopen = function() {
                log('** socket open');
                sock_send_str('{ "msg_type": "rt_connect" }');
                };

    sock.onmessage = function(e) {
                var json_msg = JSON.parse(e.data);
                if (json_msg.msg_type != null && json_msg.msg_type == "rt_nok")
                {
                    log('<span class="log_error">** '+e.data+'</span>');
                    return;
                }
                log(e.data)
                handle_records(e.data);
                };

    sock.onclose = function() {
                    log('** socket closed');
                };
}

function sock_close()
{
    log('** closing socket...');
    sock.close();
}

function sock_send(input_name)
{
    var msg = document.getElementById(input_name).value;
   
    sock_send_str(msg);
}

function sock_send_str(msg)
{
    if (sock == null)
    {
	    log('<span style="color: red;">Socket not yet connected</span>');
	    return;
    }
    if (sock.readyState == SockJS.CONNECTING)
    {
	    log('<span style="color: red;">Socket connecting...</span>');
  	    return;
    }
    if (sock.readyState == SockJS.CLOSING)
    {
	    log('<span style="color: red;">Socket closing...</span>');
	    return;
    }
    if (sock.readyState == SockJS.CLOSED)
    {
	    log('<span style="color: red;">Socket closed</span>');
	    return;
    }

    log('sending: '+msg);

    // write msg into scratchpad textarea
    document.getElementById('rt_scratchpad').value = msg;

    sock.send(msg);
}

// ****************************************************************************************
// *************** User interaction functions *********************************************
// ****************************************************************************************

// Draw the (test) stops on the map and provide a custom marker for each with a popup
function draw_stops()
{
    for (var stop_id in stops)
    {
        if (stops.hasOwnProperty(stop_id))
        {
            var stop = stops[stop_id];
            var bus_stop_marker = L.marker([stop.lat, stop.lng], {icon: bus_stop_icon})
                .addTo(map)
                .bindPopup(stop.common_name);
            // store marker for future manipulation of popup
            stops[stop_id].marker = bus_stop_marker;
        }
    }
}

// Draw the straight lines between stops on the selected journey
// The journey stops data is stored in 'journeys' created at startup
function draw_journey(vehicle_journey_id)
{
    // Get journey route (sequence of stops).
    // For data structure see global 'journeys' declaration.
    // The 'stops' array is in journeys[vehicle_journey_id].route
    var journey = journeys[vehicle_journey_id];

    // And simply draw the polyline between the stops
    var poly_line = L.polyline([], {color: 'red'}).addTo(map);
    journey.poly_line = poly_line;
    log('Drawing journey '+vehicle_journey_id+', length '+journey.route.length);
    for (var i=0; i<journey.route.length; i++)
    {
        if (journey.route[i])
        {
            var route_stop = journey.route[i];
            var stop_id = route_stop.stop_id;
            //console.log('draw_journey() ' +stop_id);
            var stop = stops[stop_id];
            //console.log('stops['+stop_id+']='+stop.stop_id+' lat,lng='+stop.lat+','+stop.lng);

            // update stop popup with time for this journey
            stop.marker.setPopupContent(stop.common_name+'</br>'+route_stop.time);

            // add journey segment to map
            var p = new L.LatLng(stop.lat, stop.lng);
            journey.poly_line.addLatLng(p);

            // add arrow
            if (journey.route[i].arrow)
            {
                journey.route[i].arrow.addTo(map);
            }
        }
    }
}

// draw a line between points A and B as {lat:, lng:}
function draw_line(A,B, color)
{
    if (!color) color = 'green';
    var line = L.polyline([[A.lat, A.lng],[B.lat,B.lng]], {color: color}).addTo(map);
    return line;
}

function draw_circle(A,radius,color)
{
    if (!color) color = 'green';
    var circle = L.circle([A.lat, A.lng],radius,{color: color}).addTo(map);
    return circle;
}

// toggle the 'breadcrumbs' function that draws a dot every time a sensor position is received
function click_breadcrumbs()
{
    breadcrumbs = document.getElementById("breadcrumbs").checked == true;
}

// switch the console log between newest msg on top vs newest on bottom
function click_log_append()
{
    var prev_log_append = log_append;
    log_append = document.getElementById("log_append").checked == true;
    if (prev_log_append != log_append)
    {
        log_reverse();
    }
}

// remove all markers from map and reset 'sensors' array
function clear_markers()
{
    //console.log('clear_markers');
    for (sensor_id in sensors)
    {
        if (sensors[sensor_id]['marker'])
        {
            map.removeLayer(sensors[sensor_id]['marker']);
        }
    }
    sensors = {};
}

// remove all crumbs from map
function clear_crumbs()
{
    for (var i=0; i<crumbs.length; i++)
    {
        map.removeLayer(crumbs[i]);
    }
    crumbs = [];
}

// empty textarea e.g. scratchpad
function clear_textarea(element_id)
{
    document.getElementById(element_id).value='';
}

function marker_to_pos(marker)
{
    var lat_lng = marker.getLatLng();
    return '{  "lat": '+lat_lng.lat+', "lng": '+lat_lng.lng+' }';
}

// issue a request to server for the latest message
function request_latest_msg()
{
    sock_send_str('{ "msg_type": "rt_request", "request_id": "A", "options": [ "latest_msg" ] }');
}

// issue a request to server for the latest records
function request_latest_records()
{
    sock_send_str('{ "msg_type": "rt_request", "request_id": "A", "options": [ "latest_records" ] }');
}

// issue a subscription to server for all records
function subscribe_all()
{
    sock_send_str('{ "msg_type": "rt_subscribe", "request_id": "A" }');
}

// User has clicked on map.
// If 'poly_draw' is true then draw a polygon on the map and 
// update the realtime scratchpad with a matching 'inside' request
function click_map(e)
{
    if (poly_draw)
    {
        var marker = new L.marker(e.latlng); 
        if (poly_markers.length == 0)
        {
            marker.addTo(map);
            poly_start = marker;
        }
        poly_line.addLatLng(marker.getLatLng());
        poly_markers.push(marker);
        var rt_string = '';
        rt_string += '{ "msg_type": "rt_request",\n';
        rt_string += '  "request_id": "A",\n';
        rt_string += '  "options": [ "latest_records" ],\n';
        if ( poly_markers.length > 2)
        {
            // add polygon closing line (and remove previous closing line)
            if (poly_close != null)
            {
                map.removeLayer(poly_close);
            }
            poly_close = L.polyline([], {dashArray: '10,5', color: 'red'}).addTo(map);
            poly_close.addLatLng(marker.getLatLng());
            poly_close.addLatLng(poly_markers[0].getLatLng());

            // update user scratchpad with filter text

            rt_string += '  "filters": [\n';
            rt_string += '     { "test": "inside",\n';
            rt_string += '       "lat_key": "Latitude",\n';
            rt_string += '       "lng_key": "Longitude",\n';
            rt_string += '       "points": [\n';
            for (var i=0; i<poly_markers.length; i++)
            {
                rt_string += marker_to_pos(poly_markers[i]);
                if (i < poly_markers.length - 1)
                    rt_string += ',\n';
            }
            rt_string += '                 ]\n';
            rt_string += '             } ]\n';
            rt_string += '}';
        }
        document.getElementById('rt_scratchpad').value = rt_string;
    }
}

// Draw a polygon for the 'inside' filter test
function draw_poly()
{
    var el = document.getElementById('draw_poly');
    poly_draw = !poly_draw;
    el.value = poly_draw ? "Clear Polygon" : "Draw Polygon";
    if (poly_draw)
    {
        poly_line = L.polyline([], {color: 'red'}).addTo(map);
    }
    else
    {
        if (poly_line != null)
        {
            map.removeLayer(poly_line);
        }

        if (poly_close != null)
        {
            map.removeLayer(poly_close);
        }

        for (var i=0; i<poly_markers.length; i++)
        {
            map.removeLayer(poly_markers[i]);
        }
        poly_markers = [];
    }
}

// user clicked on 'journey' in sensor popup
function click_journey(sensor_id)
{
    var vehicle_journey_id = sensors[sensor_id].state.vehicle_journey_id;
    if (!vehicle_journey_id)
    {
        log('<span style="{ color: red }">No journey available for sensor '+sensor_id+'</span>');
        return;
    }
    draw_journey(vehicle_journey_id);
}

// user clicked on 'more' in sensor popup                          
function click_more(sensor_id)
{
    var sensor = sensors[sensor_id];
    sensor.marker.setPopupContent(more_content(sensor_id));
}

// user clicked on 'less' in sensor popup
function click_less(sensor_id)
{
    var sensor = sensors[sensor_id];
    sensor.marker.setPopupContent(popup_content(sensor.msg));
}

// user has clicked to only show the map
function page_map()
{
    map_only = true;
    document.getElementById('control_div').style.display = 'none';
    document.getElementById('map').style.width = '99%';
    document.getElementById('map').style.height = '99%';
    map.invalidateSize();
}

// User has 'escaped' from map_only mode
function page_normal()
{
    map_only = false;
    document.getElementById('control_div').style.display = '';
    document.getElementById('map').style.width = '68%';
    document.getElementById('map').style.height = '80%';
    map.invalidateSize();
}

// ********************
// Recording buttons

function record_start()
{
    recording_on = true;
    document.getElementById('record_start').value = 'Recording';
}

function record_clear()
{
    recording_on = false;
    recorded_records = [];
    document.getElementById('record_start').value = 'Record';
}

function record_print()
{
    console.log('Printing '+recorded_records.length+' recorded records '+new Date());
    for (var i=0; i<recorded_records.length; i++)
    {
        console.log(recorded_records[i]);
    }
}

// user clicked 'Replay' button
function replay_start()
{
    // get start time from text box (js compatible)
    var start_time = new Date(document.getElementById('replay_start').value);
    if (!start_time)
    {
        log('<span style="color: red">'+
            'Bad replay start time format (try 2017-11-20T06:00:00Z)'+
            '</span>');
        return;
    }

    // if not paused, initialize the replay time to the chosen start time
    if (!replay_on)
    {
        replay_time = start_time.getTime()/1000;

        replay_index = 0;

        // set 'replay mode' flag
        replay_on = true;

        log('Replay started '+new Date(replay_time*1000));
    }
    // kick off regular timer
    replay_timer = setInterval(replay_step, replay_interval * 1000);
    log('Timer started '+new Date(replay_time*1000));
}

function replay_pause()
{
    clearInterval(replay_timer);
    log('Replay paused at '+new Date(replay_time*1000));
}

function replay_stop()
{
    clearInterval(replay_timer);
    // Reset 'replay mode' flag
    replay_on = false;
    log('Replay stopped at '+new Date(replay_time*1000));
}

function click_replay_speedup()
{
    replay_speedup = document.getElementById('replay_speedup').value;
    log('Changed replay speedup to '+replay_speedup);
}

function click_show_map()
{
    show_map = document.getElementById("show_map").checked == true;
    if (!show_map)
    {
        map.removeLayer(map_tiles);
    }
    else
    {
        map.addLayer(map_tiles);
    }
}

</script>
 
</head>

<!-- ************************************************************************************** -->
<!-- ************************************************************************************** -->
<!-- *********  PAGE HTML      ************************************************************ -->
<!-- ************************************************************************************** -->
<!-- ************************************************************************************** -->
<body onload='init()'>

<div id="control_div" class="top-aligned control_div">
<h1>RTMonitor <span id='clock'></span></h1>
<div><a href="#" onclick="page_map()">only show map</a>
</div>
<div class="control_box">
    <button onclick="sock_connect('nginx')"
        title="Connect socket to server and send rt_connect msg"
        >Connect</button>  
    <button onclick="sock_close()"
        title="Close socket connection to server"
        >Close</button><br/> 
    <button onclick="request_latest_msg()"
        title="Get the latest eventbus message from the server"
        >Request msg</button>
    <button onclick="request_latest_records()"
        title="Get all the latest data records accumulated on the server"
        >Request records</button>
    <button onclick="subscribe_all()"
        title="Get a 'push' real-time subscription to all the data records as they arrive"
        >Subscribe All</button><br/>
    <input type="button" id="draw_poly" onclick="draw_poly()" value="Draw Polygon"
        title="Draw a polygon on the map to create an API 'inside' filter in scratchpad"
        ></input>
    <input type="button" id="clear_markers" onclick="clear_markers()" value="Clear icons"
        title="Remove any sensor icons that have been drawn on the map"
        ></input>
    <input type="button" id="clear_crumbs" onclick="clear_crumbs()" value="Clear breadcrumbs"
        title="Remove any breadcrumbs that have been drawn on the map"
        ></input>
</div>
<div>Log oldest to newest: <input id="log_append" type="checkbox" onclick="click_log_append()"/>
Breadcrumbs: <input id="breadcrumbs" type="checkbox" onclick="click_breadcrumbs()"/>
</div>
<div class="control_box">
    <input type="button" id="record_start" onclick="record_start()" value="Record"
        title="Record the data as it arrives"
        ></input>
    <input type="button" id="record_clear" onclick="record_clear()" value="Clear"
        title="Cancel recording"
        ></input>
    <input type="button" id="record_print" onclick="record_print()" value="Print"
        title="Print the recorded data to the console"
        ></input>
</div>

<div class="control_box">
    <button onclick="draw_journey(DEBUG_VEHICLE_JOURNEY_ID)"
        title="Draw test journey"
        >Draw journey</button>
    Show map: <input id="show_map" type="checkbox" onclick="click_show_map()" checked/><br/>
    <button onclick="replay_start()"
        title="Replay test SiriVM data"
        >Replay</button>
    <input id="replay_start" type="text" size="22" value="2017-11-20T06:00:00Z"></input><br/>
    <button onclick="replay_pause()"
        title="Pause replay"
        >Pause</button>
    <button onclick="replay_stop()"
        title="Stop replay"
        >Stop</button>
    Speedup: <input id="replay_speedup" type="text" size="4" value="10" 
                onchange="click_replay_speedup()"></input>
</div>

<h4>Realtime API scratchpad:</h4>

<div class="scratchpad_box">
<div class="button_box">
  <button class="verticle_button" onclick="sock_send('rt_scratchpad')">Send:</button>
  <button class="verticle_button" onclick="clear_textarea('rt_scratchpad')">Clear</button>
</div>

<textarea rows="25" cols="50" id="rt_scratchpad">
{ "msg_type": "rt_subscribe",
  "request_id": "A",
  "filters" : [
                {"test": "=",
		 "key": "VehicleRef",
                 "value": "ABC"
                }
              ]
}
</textarea>
</div>

</div> <!-- end of control_div -->

<!-- MAP -->
<div class="top-aligned" id="map"></div>

<!-- console log -->
<div id="console_div"></div>
  
</body>
</html>
